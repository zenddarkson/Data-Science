# -*- coding: utf-8 -*-
"""EDA_Lab02_Custodio.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MSkvnHB-j1UihOxMQwnFjvTNRDXTS1Qe
"""

# EDA conjunto de datos proporcionado del Desa􀄰o de Datos PHME 2022
# Armando Arturo Custodio Díaz
# 20196355
# a.custodio@pucp.edu.pe

# Importando librerias

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from google.colab import drive
from scipy.fft import fft, ifft

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# Conectando google drive con google colab
drive.mount('/content/drive')

"""# 1. Visión General de los Datos (5 puntos):

Cargar e inspeccionar el conjunto de datos.
"""

# Cargar la data
path='/content/drive/MyDrive/TemasH/Lab02/'

PHME_data_train=pd.read_csv(path+'SPI_testing_0.csv')

PHME_data_train.head()

"""Identificar las dimensiones del conjunto (número de filas y columnas)."""

# •	Identificar las dimensiones del conjunto (número de filas y columnas).
PHME_data_train.shape

"""Identificar los tipos de datos (integer, object, float, etc)."""

PHME_data_train.info()

"""Determinar los tipos de variables (categóricas, continuas, etc.)

Variables Categoricas

*   Variables Nominales: ComponentID, PanelID, FigureID, PinNumber, PadID, PadType, FigureID, Result
*   Variables Ordinales:

Variables Numericas

*   Variables Continuas: Volume(%), Height(um), Area(%), OffsetX(%),      OffsetY(%), SizeX, SizeY, Volume(um3), Area(um2), Shape(um), PosX(mm), PosY(mm)
*   Variables Discretas:  

Variables de Tiempo:  Date, Time

Establecer el identificador único de la data.
"""

# PHME_data_train.groupby('PanelID').nunique().reset_index().shape[0]

if PHME_data_train.groupby(['PanelID','FigureID','ComponentID','PinNumber']).nunique().reset_index().shape[0] == PHME_data_train.shape[0]:
  print('identificador unico encontrado!')
else:
  print('no se encontro')

# Esto se ha obtenido dada la información en la pagina:
#   "In this scenario, the SPI data, reports, for each PCB, characteristics such as Identifiers: PanelID, FigureID, ComponentID, PinNumber"

"""#Limpieza de Datos (3 puntos):

Identificar y tratar cualquier anomalía o valor atipico en las variables 'Volume(%)' y 'Area(%)'.
"""

# VOLUME
# AREA

# En este caso, escojo usar la regla de 99.7%, pues al usar la regla del 95%, se forman picos en los DensityPlot

def sigma_rule(df):

    rule = (100-99.7)/2

    data = PHME_data_train[df].copy()

    # Calculating bounds for 2-sigma rule (approximately 2.5th and 97.5th percentiles)
    lower_bound = np.percentile(data, rule)
    upper_bound = np.percentile(data, 100-rule)

    # Identifying outliers
    outliers = data[(data < lower_bound) | (data > upper_bound)]

    # Replacing outliers with NaN values
    PHME_data_train.loc[outliers.index, df] = np.nan

sigma_rule('Volume(%)')
sigma_rule('Area(%)')

# TERCERA VARIABLE NUMÉRICA CONTINUA: Height(um)
sigma_rule('Height(um)')

"""Verificar la existencia de valores faltantes y manejarlos adecuadamente."""

def missing_values_table(df):
        # Total missing values
        mis_val = df.isnull().sum()

        # Percentage of missing values
        mis_val_percent = 100 * df.isnull().sum() / len(df)

        # Make a table with the results
        mis_val_table = pd.concat([mis_val, mis_val_percent], axis=1)

        # Rename the columns
        mis_val_table_ren_columns = mis_val_table.rename(
        columns = {0 : 'Missing Values', 1 : '% of Total Values'})

        # Sort the table by percentage of missing descending
        mis_val_table_ren_columns = mis_val_table_ren_columns[
            mis_val_table_ren_columns.iloc[:,1] != 0].sort_values(
        '% of Total Values', ascending=False).round(1)

        # Print some summary information
        print ("Your selected dataframe has " + str(df.shape[1]) + " columns.\n"
            "There are " + str(mis_val_table_ren_columns.shape[0]) +
              " columns that have missing values.")

        # Return the dataframe with missing information
        return mis_val_table_ren_columns

missing_values_table(PHME_data_train)

# Llenando los valores nulos de variables categoricas con mean
PHME_data_train['Volume(%)']=PHME_data_train['Volume(%)'].fillna(PHME_data_train['Volume(%)'].mean())
PHME_data_train['Area(%)']=PHME_data_train['Area(%)'].fillna(PHME_data_train['Area(%)'].mean())
PHME_data_train['Height(um)']=PHME_data_train['Height(um)'].fillna(PHME_data_train['Height(um)'].mean())

missing_values_table(PHME_data_train)

"""#Análisis Estadístico (2 puntos):

Calcular y mostrar en una tabla las estadísticas resumidas (media, mínimo, máximo, desviación estándar, etc.).
"""

# Calcular y mostrar en una tabla las estadísticas resumidas (media, mínimo, máximo, desviación estándar, etc.).
PHME_data_train.describe()

"""#Visualización de Datos (6 puntos):

Crear tres gráficos de barras de frecuencias relativas para tres variables categóricas y tres gráficos de densidad para tres variables numéricas continuas. Seis gráficos en total. Comentar cada gráfico.
"""

# Variables nominales

# Calculate relative frequencies

def relative_plot(df):
  relative_freq = PHME_data_train[df].value_counts(normalize=True)

  # Plot
  plt.figure(figsize=(18, 12))
  relative_freq.plot(kind='bar')
  plt.ylabel('Relative Frequency')
  plt.title('Graph of ' + df)
  plt.xticks(rotation=90)

  plt.show()

relative_plot('PinNumber')
relative_plot('Result')
relative_plot('FigureID')

# Creating the density plot
def density_plot(df):

  sns.set(style="whitegrid")
  plt.figure(figsize=(18, 12))

  # Use df instead of hardcoding the column name 'Age'
  sns.kdeplot(PHME_data_train[df], bw_adjust=0.5)

  plt.title('Density Plot of ' + df)
  plt.xlabel(df)
  plt.ylabel('Density')
  plt.show()

density_plot('Volume(%)')
density_plot('Area(%)')
density_plot('Height(um)')

"""De

Crear un ‘Correlation Heat Map’ para examinar las correlaciones entre las variables y comentar los hallazgos.
"""

corr_matrix = PHME_data_train.corr()

# Creando la grafica
plt.figure(figsize=(18, 16))

sns.heatmap(corr_matrix, annot=True, fmt=".2f", cmap='coolwarm',
            xticklabels=corr_matrix.columns,
            yticklabels=corr_matrix.columns,
            square=True, linewidths=.5, cbar_kws={"shrink": .5})

plt.title('Correlation Heatmap')
plt.show()